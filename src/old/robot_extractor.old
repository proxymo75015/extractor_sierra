/* 
 * robot_extractor.cpp – Outil C++ autonome pour décompresser les ressources vidéo Sierra “Robot” (*.rbt)
 * Version 1.2.8 avec gestion d'erreurs robuste, journalisation thread-safe, support Unicode, compatibilité Robot v4-v6,
 * lecture générique avec <bit>, nouvelles options CLI, optimisation mémoire avec std::byte, validation des noms de fichiers,
 * protection contre les divisions par zéro, palette et copie de données optimisées, pré-allocation LZS, RAII pour exceptions,
 * et enum pour types de compression
 * License: MIT
 *
 * Dépendances externes:
 * - nlohmann/json (v3.11.2+)
 * - stb_image_write (avec patch STBI_WINDOWS_UTF8)
 *   Source: https://github.com/nothings/stb/pull/1382
 */

#include "stb_image_write.h"
#include "utilities.hpp"

#include <array>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cstdio>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <mutex>
#include <unordered_map>
#include <nlohmann/json.hpp>
#include <span>
#include <string>
#include <vector>
#include <cmath>
#include <algorithm>
#include <stdexcept>
#include <chrono>
#include <sstream>
#include <bit>

#if defined(_WIN32)
#define NOMINMAX
#include <fcntl.h>
#include <io.h>
#include <windows.h>
#endif

namespace fs = std::filesystem;

// Helper pour conversion std::byte -> uint8_t
constexpr uint8_t to_u8(std::byte b) noexcept {
    return static_cast<uint8_t>(b);
}

// Helper pour conversion uint8_t -> std::byte
constexpr std::byte to_byte(uint8_t b) noexcept {
    return static_cast<std::byte>(b);
}

// Helper pour valider les noms de fichiers
static bool is_valid_filename(const std::string& s) {
    static constexpr std::string_view bad = R"(\/:*?"<>|)";
    
    if (std::any_of(s.begin(), s.end(), [](char c) { return bad.find(c) != std::string::npos; })) {
        return false;
    }
    
#if defined(_WIN32)
    static constexpr std::array<const char*, 23> reserved_names = {
        "CON", "PRN", "AUX", "NUL",
        "COM0", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
        "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"
    };
    
    std::string base = s;
    size_t lastdot = s.find_last_of('.');
    if (lastdot != std::string::npos) {
        base = s.substr(0, lastdot);
    } else {
        base = s;
    }
    
    for (const auto& reserved : reserved_names) {
        if (_stricmp(base.c_str(), reserved) == 0) {
            return false;
        }
    }
#endif
    return true;
}

// Enum pour les types de compression
enum class CompressionType : uint16_t {
    LZS = 0,
    RAW = 1
};

// RAII pour la gestion des exceptions de flux
class StreamExceptionGuard {
    std::ifstream& stream;
    std::ios_base::iostate original_state;
public:
    explicit StreamExceptionGuard(std::ifstream& s) 
        : stream(s), original_state(s.exceptions()) {}
    
    ~StreamExceptionGuard() {
        stream.exceptions(original_state);
    }
};

// ─────────────────────────────────────────────────────────────────────────────
//  Constantes globales
// ─────────────────────────────────────────────────────────────────────────────
constexpr size_t kMaxCelPixels = 100'000'000;
constexpr size_t kMaxLzsOutput = 10'000'000;
constexpr uint16_t kRobotSig = 0x0016;
constexpr std::array<char, 4> kSolTag = {'S', 'O', 'L', '\0'};
constexpr size_t kMaxPathLength = 4096;
constexpr size_t kMaxWin32PathLength = 32767;

// ─────────────────────────────────────────────────────────────────────────────
//  Options globales
// ─────────────────────────────────────────────────────────────────────────────
static bool g_quiet = false;
static std::string g_gammaMode = "precise";
static fs::path g_outputDir = "";
static bool g_validateOnly = false;

// ─────────────────────────────────────────────────────────────────────────────
//  Lecteur générique endian-agnostique avec byteswap
// ─────────────────────────────────────────────────────────────────────────────
template <typename T>
T read_scalar(std::ifstream &f, bool bigEndian) {
    constexpr size_t size = sizeof(T);
    std::array<uint8_t, size> bytes;
    f.read(reinterpret_cast<char*>(bytes.data()), size);
    if (f.gcount() != static_cast<std::streamsize>(size)) 
        throw std::runtime_error("EOF inattendu");

    T value;
    std::memcpy(&value, bytes.data(), size);
    
    if constexpr (size > 1) {
        if (bigEndian != (std::endian::native == std::endian::big)) {
            #if defined(__cpp_lib_byteswap) || (__cplusplus >= 202302L)
            return std::byteswap(value);
            #else
            T swapped = 0;
            for (size_t i = 0; i < size; ++i) {
                swapped |= static_cast<T>(bytes[i]) << (8 * (size - 1 - i));
            }
            return swapped;
            #endif
        }
    }
    return value;
}

template <typename T>
T read_scalar(std::span<const uint8_t> data, bool bigEndian, size_t offset) {
    if (offset + sizeof(T) > data.size()) {
        throw std::runtime_error("Données insuffisantes pour la lecture de scalaire");
    }
    T value;
    std::memcpy(&value, data.data() + offset, sizeof(T));
    
    if constexpr (sizeof(T) > 1) {
        if (bigEndian != (std::endian::native == std::endian::big)) {
            #if defined(__cpp_lib_byteswap) || (__cplusplus >= 202302L)
            return std::byteswap(value);
            #else
            T swapped = 0;
            for (size_t i = 0; i < sizeof(T); ++i) {
                swapped |= static_cast<T>(data[offset + i]) << (8 * (sizeof(T) - 1 - i));
            }
            return swapped;
            #endif
        }
    }
    return value;
}

// ─────────────────────────────────────────────────────────────────────────────
//  Barre de progression
// ─────────────────────────────────────────────────────────────────────────────
void show_progress(size_t frameIdx, size_t totalFrames, std::chrono::steady_clock::time_point startTime, const fs::path& srcPath) {
    if (g_quiet || g_validateOnly || frameIdx % 20 != 0) return;

    static std::mutex progress_mutex;
    std::lock_guard<std::mutex> lock(progress_mutex);
    constexpr int barWidth = 50;
    float progress = static_cast<float>(frameIdx) / totalFrames;
    int pos = static_cast<int>(barWidth * progress);
    std::cout << "\r[" << srcPath.string() << "] Progression : [";
    for (int i = 0; i < barWidth; ++i) std::cout << (i < pos ? "#" : "-");
    std::cout << "] " << std::fixed << std::setprecision(1) << progress * 100.0 << "%";

    if (frameIdx > 0 && frameIdx < totalFrames) {
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
        if (elapsed < 1) elapsed = 1;
        double fps = frameIdx / (elapsed / 1000.0);
        double eta = (totalFrames - frameIdx) / fps;
        if (eta > 60) {
            int minutes = static_cast<int>(eta / 60);
            int seconds = static_cast<int>(std::round(eta - 60 * minutes));
            std::cout << " ETA : " << minutes << "m" << seconds << "s";
        } else {
            std::cout << " ETA : " << static_cast<int>(std::round(eta)) << "s";
        }
        std::cout << " (" << std::fixed << std::setprecision(1) << fps << " fps)";
    }
    std::cout << std::flush;
}

// ─────────────────────────────────────────────────────────────────────────────
//  Décompression LZS
// ─────────────────────────────────────────────────────────────────────────────
auto lzs_decompress(std::span<const uint8_t> in) -> std::vector<std::byte> {
    std::vector<std::byte> out;
    out.resize(std::min(in.size() * 4, kMaxLzsOutput)); // Pré-allocation
    size_t out_index = 0;

    size_t i = 0;
    while (i < in.size()) {
        uint8_t control = in[i++];
        for (int bit = 0; bit < 8 && i < in.size(); ++bit) {
            if (control & (1 << bit)) {
                if (out_index >= out.size()) {
                    throw std::runtime_error("Taille de sortie LZS dépassée");
                }
                out[out_index++] = static_cast<std::byte>(in[i++]);
            } else {
                if (i + 1 >= in.size()) {
                    throw std::runtime_error("Bloc de contrôle LZS incomplet");
                }
                uint8_t b1 = in[i++];
                uint8_t b2 = in[i++];
                size_t length = (b1 >> 4) + 3;
                size_t offset = ((b1 & 0x0F) << 8) | b2;
                
                if (length == 0 || offset == 0 || offset > out_index) {
                    throw std::runtime_error("Paramètres LZS invalides : offset=" + 
                                             std::to_string(offset) + 
                                             ", taille du buffer=" + 
                                             std::to_string(out_index));
                }
                offset++;

                const size_t newSize = out_index + length;
                if (newSize > kMaxLzsOutput) {
                    throw std::runtime_error("Taille de sortie LZS dépassée");
                }
                if (newSize > out.size()) {
                    out.resize(std::min(newSize * 2, kMaxLzsOutput));
                }
                
                for (size_t k = 0; k < length; ++k) {
                    out[out_index++] = out[out_index - offset];
                }
            }
        }
    }
    if (out_index > kMaxCelPixels) {
        throw std::runtime_error("Taille de cel excessive après décompression LZS");
    }
    out.resize(out_index); // Ajuster la taille finale
    return out;
}

// ─────────────────────────────────────────────────────────────────────────────
//  Décompression DPCM-16 (Sierra SOL)
// ─────────────────────────────────────────────────────────────────────────────
auto dpcm16_decompress(std::span<const uint8_t> in, int16_t &predictor) -> std::vector<int16_t> {
    std::vector<int16_t> pcm;
    try {
        pcm.reserve(in.size() * 2);
    } catch (const std::bad_alloc&) {
        log_error(fs::path(), "Échec de l'allocation mémoire pour le buffer de décompression DPCM");
        return pcm;
    }
    static constexpr std::array<int16_t, 16> DPCM_TABLE = {
        -0x0c0, -0x080, -0x040, -0x020, -0x010, -0x008, -0x004, -0x002,
         0x002,  0x004,  0x008,  0x010,  0x020,  0x040,  0x080,  0x0c0,
    };
    for (uint8_t b : in) {
        uint8_t hi = b >> 4, lo = b & 0x0F;
        for (uint8_t nib : {hi, lo}) {
            int32_t tmp = predictor + DPCM_TABLE[nib];
            predictor = static_cast<int16_t>(std::clamp(tmp, -32768, 32767));
            if (predictor > 32767 || predictor < -32768) {
                log_error(fs::path(), "Débordement du prédicteur DPCM");
                predictor = 0;
            }
            pcm.push_back(predictor);
        }
    }
    return pcm;
}

// ─────────────────────────────────────────────────────────────────────────────
//  Écrivain WAV
// ─────────────────────────────────────────────────────────────────────────────
void write_wav(const fs::path &out, std::span<const int16_t> samplesEven, std::span<const int16_t> samplesOdd, uint32_t sampleRate) {
    fs::path longPath = make_long_path(out);
    std::ofstream f(longPath, std::ios::binary);
    if (!f) {
        log_error(out, "Échec de l'ouverture du fichier WAV pour écriture (disque plein ?)");
        return;
    }

    bool isMono = samplesEven.empty() || samplesOdd.empty();
    size_t n = isMono ? std::max(samplesEven.size(), samplesOdd.size()) : std::max(samplesEven.size(), samplesOdd.size());
    uint16_t numChannels = isMono ? 1 : 2;
    uint32_t dataSize = static_cast<uint32_t>(n * numChannels * 2);
    uint32_t riffSize = 36 + dataSize;
    uint32_t byteRate = sampleRate * numChannels * 2;
    uint16_t blockAlign = numChannels * 2;

    f.write("RIFF", 4);
    f.write(reinterpret_cast<char*>(&riffSize), 4);
    f.write("WAVEfmt ", 8);
    uint32_t subSize = 16;
    uint16_t audioFormat = 1;
    uint16_t bitsPerSample = 16;
    f.write(reinterpret_cast<char*>(&subSize), 4);
    f.write(reinterpret_cast<char*>(&audioFormat), 2);
    f.write(reinterpret_cast<char*>(&numChannels), 2);
    f.write(reinterpret_cast<char*>(&sampleRate), 4);
    f.write(reinterpret_cast<char*>(&byteRate), 4);
    f.write(reinterpret_cast<char*>(&blockAlign), 2);
    f.write(reinterpret_cast<char*>(&bitsPerSample), 2);
    f.write("data", 4);
    f.write(reinterpret_cast<char*>(&dataSize), 4);

    std::vector<int16_t> output;
    try {
        output.resize(n * numChannels);
    } catch (const std::bad_alloc&) {
        log_error(out, "Échec de l'allocation mémoire pour le buffer de sortie WAV");
        return;
    }

    int16_t lastEven = samplesEven.empty() ? 0 : samplesEven.back();
    int16_t lastOdd = samplesOdd.empty() ? 0 : samplesOdd.back();

    if (isMono) {
        auto& samples = samplesEven.empty() ? samplesOdd : samplesEven;
        for (size_t i = 0; i < n; ++i) {
            output[i] = i < samples.size() ? samples[i] : (samplesEven.empty() ? lastOdd : lastEven);
        }
    } else {
        for (size_t i = 0; i < n; ++i) {
            output[i * 2] = i < samplesEven.size() ? samplesEven[i] : lastEven;
            output[i * 2 + 1] = i < samplesOdd.size() ? samplesOdd[i] : lastOdd;
        }
    }

    f.write(reinterpret_cast<const char*>(output.data()), dataSize);
    if (!f) {
        log_error(out, "Échec de l'écriture des données WAV (disque plein ?)");
        return;
    }
    f.close();
    log_info(out, "Fichier WAV " + std::string(isMono ? "mono" : "stéréo") + " écrit avec succès avec un taux d'échantillonnage de " + std::to_string(sampleRate) + " Hz");
}

// ─────────────────────────────────────────────────────────────────────────────
//  Rééchantillonnage vertical
// ─────────────────────────────────────────────────────────────────────────────
auto rescaleCel(const std::vector<std::byte>& pixels, int w, int h, uint8_t vScale, int16_t& y, const fs::path& srcPath) -> std::vector<std::byte> {
    if (vScale == 100 || vScale == 0) return pixels;
    if (vScale < 25 || vScale > 400) {
        log_error(srcPath, "vScale invalide : " + std::to_string(static_cast<int>(vScale)));
        return pixels;
    }
    int newH = h * vScale / 100;
    y = y * vScale / 100;
    std::vector<std::byte> scaled;
    try {
        scaled.resize(static_cast<size_t>(w) * newH);
    } catch (const std::bad_alloc&) {
        log_error(srcPath, "Échec de l'allocation mémoire pour le cel redimensionné : " + std::to_string(w) + "x" + std::to_string(newH));
        return pixels;
    }
    for (int y_new = 0; y_new < newH; ++y_new) {
        int srcY = y_new * h / newH;
        auto* dst = scaled.data() + y_new * w;
        const auto* src = pixels.data() + srcY * w;
        std::memcpy(dst, src, static_cast<size_t>(w));
    }
    return scaled;
}

// ─────────────────────────────────────────────────────────────────────────────
//  RobotExtractor
// ─────────────────────────────────────────────────────────────────────────────
class RobotExtractor {
public:
    explicit RobotExtractor(const fs::path& srcPath) : m_srcPath(srcPath), m_bigEndian(false) {}
    static constexpr const char* EXTRACTOR_VERSION = "1.2.8";
    bool extract();
    bool validate();

private:
    bool readHeader();
    void exportPalette(const fs::path& out);
    void exportFrame(int frameIdx, std::span<const uint8_t> frameData, const fs::path& dir, size_t& celCount);
    void processAudioBlock(std::span<const uint8_t> block, int16_t& predictorEven, int16_t& predictorOdd);

    fs::path m_srcPath;
    std::ifstream m_fp;
    bool m_bigEndian;

    uint16_t m_version = 0;
    uint16_t m_audioBlkSize = 0;
    bool m_primerZeroComp = false;
    uint16_t m_numFrames = 0;
    uint16_t m_paletteSize = 0;
    uint16_t m_primerReserved = 0;
    int16_t m_xRes = 0;
    int16_t m_yRes = 0;
    bool m_hasPalette = false;
    bool m_hasAudio = false;
    int16_t m_frameRate = 0;
    uint16_t m_maxCelsPerFrame = 0;
    std::array<int32_t, 4> m_maxCelArea{};

    std::vector<uint32_t> m_videoSizes;
    std::vector<uint32_t> m_packetSizes;
    std::vector<int32_t> m_cueTimes;
    std::vector<uint16_t> m_cueValues;

    std::vector<std::byte> m_palette;
    struct AudioBlock {
        uint32_t position;
        std::vector<int16_t> samples;
        bool isEven;
    };
    std::vector<AudioBlock> m_audioBlocks;
    int16_t m_predictorEven = 0;
    int16_t m_predictorOdd = 0;

    struct CelMetadata {
        int16_t x, y;
        uint16_t w, h;
        uint8_t vScale;
        uint8_t unk0;
    };
    std::vector<std::vector<CelMetadata>> m_frameMetadata;
};

// ────────────────────────────────────────────
//  Implémentation
// ────────────────────────────────────────────
bool RobotExtractor::readHeader() {
    if (!m_fp.is_open()) {
        log_error(m_srcPath, "Impossible d'ouvrir le fichier");
        return false;
    }

    try {
        StreamExceptionGuard guard(m_fp);
        m_fp.exceptions(std::ifstream::failbit | std::ifstream::badbit);

        uint16_t sig = read_scalar<uint16_t>(m_fp, false);
        if (sig != kRobotSig) {
            log_error(m_srcPath, "Ce n'est pas un fichier Robot (signature non correspondante : 0x" + std::to_string(sig));
            return false;
        }
        
        std::array<char, 4> sol;
        m_fp.read(sol.data(), sol.size());
        if (m_fp.gcount() != 4 || sol != kSolTag) {
            log_error(m_srcPath, "Tag SOL manquant ou invalide");
            return false;
        }
        
        uint16_t verBE = read_scalar<uint16_t>(m_fp, true);
        m_bigEndian = (verBE != 0 && verBE <= 0x00FF);
        m_fp.seekg(6, std::ios::beg);

        m_version = read_scalar<uint16_t>(m_fp, m_bigEndian);
        m_audioBlkSize = read_scalar<uint16_t>(m_fp, m_bigEndian);
        m_primerZeroComp = read_scalar<int16_t>(m_fp, m_bigEndian);
        m_fp.seekg(2, std::ios::cur);
        m_numFrames = read_scalar<uint16_t>(m_fp, m_bigEndian);
        m_paletteSize = read_scalar<uint16_t>(m_fp, m_bigEndian);
        m_primerReserved = read_scalar<uint16_t>(m_fp, m_bigEndian);
        m_xRes = read_scalar<int16_t>(m_fp, m_bigEndian);
        m_yRes = read_scalar<int16_t>(m_fp, m_bigEndian);
        m_hasPalette = read_scalar<uint8_t>(m_fp, m_bigEndian);
        m_hasAudio = read_scalar<uint8_t>(m_fp, m_bigEndian);
        m_fp.seekg(2, std::ios::cur);
        m_frameRate = read_scalar<int16_t>(m_fp, m_bigEndian);
        m_fp.seekg(6, std::ios::cur);
        m_maxCelsPerFrame = read_scalar<int16_t>(m_fp, m_bigEndian);
        for (int i = 0; i < 4; ++i) m_maxCelArea[i] = read_scalar<int32_t>(m_fp, m_bigEndian);
        m_fp.seekg(8, std::ios::cur);

        if (m_maxCelsPerFrame == 0 && m_version == 4) {
            m_maxCelsPerFrame = 50;
        }

        if (m_numFrames > 100000 || m_paletteSize > 768 || m_maxCelsPerFrame > 10000) {
            log_error(m_srcPath, "Valeurs d'en-tête invalides : frames=" + std::to_string(m_numFrames) +
                      ", paletteSize=" + std::to_string(m_paletteSize) +
                      ", maxCelsPerFrame=" + std::to_string(m_maxCelsPerFrame));
            return false;
        }

        size_t paletteToRead = std::min<size_t>(m_paletteSize, 768);
        if (m_hasPalette && paletteToRead > 0) {
            try {
                m_palette.resize(paletteToRead);
            } catch (const std::bad_alloc&) {
                log_error(m_srcPath, "Échec de l'allocation mémoire pour le buffer de palette");
                return false;
            }
            m_fp.read(reinterpret_cast<char*>(m_palette.data()), paletteToRead);
            if (static_cast<size_t>(m_fp.gcount()) != paletteToRead) {
                log_error(m_srcPath, "Erreur de lecture de la palette");
                return false;
            }
            if (m_paletteSize > paletteToRead) {
                size_t ignored = m_paletteSize - paletteToRead;
                log_info(m_srcPath, "Palette tronquée : " +
                         std::to_string(paletteToRead/3) + " couleurs (" +
                         std::to_string(ignored) + " octets ignorés)");
                m_fp.seekg(ignored, std::ios::cur);
            }
        } else {
            m_fp.seekg(m_paletteSize, std::ios::cur);
        }

        if (m_primerReserved && m_hasAudio) {
            std::vector<uint8_t> primer;
            try {
                primer.resize(m_primerReserved);
            } catch (const std::bad_alloc&) {
                log_error(m_srcPath, "Échec de l'allocation mémoire pour le buffer audio de primer");
                return false;
            }
            m_fp.read(reinterpret_cast<char*>(primer.data()), m_primerReserved);
            if (m_fp.gcount() != m_primerReserved) {
                log_error(m_srcPath, "Échec de la lecture de l'audio de primer");
                return false;
            }
            if (!m_primerZeroComp) {
                auto pcm = dpcm16_decompress(primer, m_predictorEven);
                if (!pcm.empty()) {
                    m_predictorEven = pcm.back();
                    m_audioBlocks.push_back({0, pcm, true});
                }
            } else {
                m_predictorEven = 0;
                m_predictorOdd = 0;
            }
        } else {
            if (!m_hasAudio || m_primerZeroComp) {
                m_predictorEven = 0;
                m_predictorOdd = 0;
            }
            if (m_primerReserved) {
                m_fp.seekg(m_primerReserved, std::ios::cur);
            }
        }

        try {
            m_videoSizes.resize(m_numFrames);
            m_packetSizes.resize(m_numFrames);
            m_frameMetadata.resize(m_numFrames);
        } catch (const std::bad_alloc&) {
            log_error(m_srcPath, "Échec de l'allocation mémoire pour les buffers de métadonnées de frame");
            return false;
        }
        for (uint16_t i = 0; i < m_numFrames; ++i) {
            if (m_version == 4) {
                m_videoSizes[i] = read_scalar<uint16_t>(m_fp, m_bigEndian);
                m_packetSizes[i] = read_scalar<uint16_t>(m_fp, m_bigEndian);
            } else {
                m_videoSizes[i] = read_scalar<uint32_t>(m_fp, m_bigEndian);
                m_packetSizes[i] = read_scalar<uint32_t>(m_fp, m_bigEndian);
            }
            if (m_fp.fail()) {
                log_error(m_srcPath, "Échec de la lecture des tailles de frame à l'index " + std::to_string(i));
                return false;
            }
        }
        try {
            m_cueTimes.resize(256);
            m_cueValues.resize(256);
        } catch (const std::bad_alloc&) {
            log_error(m_srcPath, "Échec de l'allocation mémoire pour les buffers de cue");
            return false;
        }
        for (auto& t : m_cueTimes) {
            t = read_scalar<int32_t>(m_fp, m_bigEndian);
            if (m_fp.fail()) {
                log_error(m_srcPath, "Échec de la lecture des temps de cue");
                return false;
            }
        }
        for (auto& v : m_cueValues) {
            v = read_scalar<uint16_t>(m_fp, m_bigEndian);
            if (m_fp.fail()) {
                log_error(m_srcPath, "Échec de la lecture des valeurs de cue");
                return false;
            }
        }

        std::streamoff pos = m_fp.tellg();
        if (pos == -1) {
            log_error(m_srcPath, "Position de fichier invalide");
            return false;
        }
        std::streamoff pad = (2048 - (pos % 2048)) % 2048;
        m_fp.seekg(pad, std::ios::cur);
        if (m_fp.fail()) {
            log_error(m_srcPath, "Échec du positionnement à une position alignée");
            return false;
        }
        return m_fp.good();
    } catch (const std::ios_base::failure& e) {
        log_error(m_srcPath, "Erreur IO lors de l'analyse de l'en-tête : " + std::string(e.what()));
        return false;
    } catch (const std::exception& e) {
        log_error(m_srcPath, "Erreur d'analyse de l'en-tête : " + std::string(e.what()));
        return false;
    }
}

void RobotExtractor::exportPalette(const fs::path& out) {
    if (!m_hasPalette || m_palette.empty() || m_palette.size() % 3 != 0) {
        log_error(m_srcPath, "Palette invalide ou manquante");
        return;
    }
    int nColors = static_cast<int>(m_palette.size() / 3);
    std::vector<uint8_t> rgba;
    try {
        rgba.resize(nColors * 4);
    } catch (const std::bad_alloc&) {
        log_error(m_srcPath, "Échec de l'allocation mémoire pour le buffer RGBA de la palette");
        return;
    }

    bool useStretch = false;
    if (g_gammaMode == "legacy") {
        useStretch = true;
    } else if (g_gammaMode == "precise") {
        size_t over63 = 0;
        for (std::byte comp : m_palette) {
            if (to_u8(comp) > 63) over63++;
        }
        useStretch = (over63 * 100 / m_palette.size()) < 10;
    }

    for (int i = 0; i < nColors; ++i) {
        const size_t idx = i * 3;
        if (idx + 2 >= m_palette.size()) break;

        uint8_t r = to_u8(m_palette[idx + 0]);
        uint8_t g = to_u8(m_palette[idx + 1]);
        uint8_t b = to_u8(m_palette[idx + 2]);
        
        if (g_gammaMode == "legacy") {
            r = std::clamp(r * 4 + 3, 0, 255);
            g = std::clamp(g * 4 + 3, 0, 255);
            b = std::clamp(b * 4 + 3, 0, 255);
        } else if (useStretch) {
            r = std::clamp((r * 255) / 63, 0, 255);
            g = std::clamp((g * 255) / 63, 0, 255);
            b = std::clamp((b * 255) / 63, 0, 255);
        }

        rgba[i * 4 + 0] = r;
        rgba[i * 4 + 1] = g;
        rgba[i * 4 + 2] = b;
        rgba[i * 4 + 3] = 255;
    }
    fs::path longPath = make_long_path(out);
    if (!stbi_write_png(longPath.string().c_str(), nColors, 1, 4, rgba.data(), nColors * 4)) {
        log_error(m_srcPath, "Échec de l'écriture de la palette : " + out.string());
    } else {
        log_info(m_srcPath, "Palette exportée vers " + out.string() + " (gamma : " + g_gammaMode + ")" + 
                (useStretch ? " [étirée]" : " [brute]"));
    }
}

void RobotExtractor::exportFrame(int frameIdx, std::span<const uint8_t> frameData, const fs::path& dir, size_t& celCount) {
    celCount = 0;
    if (frameData.size() < 3) {
        log_error(m_srcPath, "Frame " + std::to_string(frameIdx) + " trop petite");
        return;
    }
    uint32_t numCels = read_scalar<uint16_t>(frameData, false, 0);
    if (m_maxCelsPerFrame > 0 && numCels > m_maxCelsPerFrame) {
        log_error(m_srcPath, "Nombre de cels invalide : " + std::to_string(numCels) + " dans la frame " + std::to_string(frameIdx));
        return;
    }
    size_t offset = 3;

    try {
        m_frameMetadata[frameIdx].resize(numCels);
    } catch (const std::bad_alloc&) {
        log_error(m_srcPath, "Échec de l'allocation mémoire pour les métadonnées de frame : frame " + std::to_string(frameIdx));
        return;
    }
    thread_local std::vector<uint8_t> rgba_buffer;
    for (uint32_t cel = 0; cel < numCels && offset + 22 <= frameData.size(); ++cel) {
        const uint8_t* hdr = frameData.data() + offset;
        offset += 22;
        uint8_t unk0 = hdr[0];
        uint8_t vScale = hdr[1];
        uint16_t w = read_scalar<uint16_t>(frameData, false, offset - 20);
        uint16_t h = read_scalar<uint16_t>(frameData, false, offset - 18);
        int16_t x = read_scalar<int16_t>(frameData, false, offset - 12);
        int16_t y = read_scalar<int16_t>(frameData, false, offset - 10);
        uint16_t nChunks = read_scalar<uint16_t>(frameData, false, offset - 6);

        if (nChunks > 10000) {
            log_error(m_srcPath, "Nombre excessif de chunks dans la frame " + std::to_string(frameIdx) +
                      ", cel " + std::to_string(cel) + ": " + std::to_string(nChunks));
            continue;
        }

        size_t pixel_count = static_cast<size_t>(w) * h;
        if (w <= 0 || h <= 0 || pixel_count > kMaxCelPixels) {
            log_error(m_srcPath, "Dimensions de cel invalides dans la frame " + std::to_string(frameIdx) +
                      ", cel " + std::to_string(cel) + ": w=" + std::to_string(w) +
                      ", h=" + std::to_string(h));
            continue;
        }

        m_frameMetadata[frameIdx][cel] = {x, y, w, h, vScale, unk0};

        std::vector<std::byte> pixelBuf;
        try {
            pixelBuf.reserve(pixel_count);
        } catch (const std::bad_alloc&) {
            log_error(m_srcPath, "Échec de l'allocation mémoire pour le cel : " + std::to_string(w) + "x" + std::to_string(h));
            continue;
        }

        for (uint16_t ch = 0; ch < nChunks && offset + 10 <= frameData.size(); ++ch) {
            uint32_t compSize = read_scalar<uint32_t>(frameData, false, offset);
            [[maybe_unused]] uint32_t decompSz = read_scalar<uint32_t>(frameData, false, offset + 4);
            uint16_t compType = read_scalar<uint16_t>(frameData, false, offset + 8);
            offset += 10;

            if (offset + compSize > frameData.size()) {
                log_error(m_srcPath, "Taille de chunk invalide dans la frame " + std::to_string(frameIdx) +
                          ", cel " + std::to_string(cel));
                break;
            }

            std::span<const uint8_t> comp(frameData.data() + offset, compSize);
            offset += compSize;

            switch (static_cast<CompressionType>(compType)) {
                case CompressionType::LZS:
                    try {
                        auto decomp = lzs_decompress(comp);
                        pixelBuf.insert(pixelBuf.end(), decomp.begin(), decomp.end());
                    } catch (const std::exception& e) {
                        log_error(m_srcPath, "Échec LZS dans la frame " +
                                  std::to_string(frameIdx) + " cel " +
                                  std::to_string(cel) + ": " + e.what());
                        continue;
                    }
                    break;
                
                case CompressionType::RAW:
                    pixelBuf.insert(pixelBuf.end(), comp.begin(), comp.end());
                    break;
                
                default:
                    log_error(m_srcPath, "Type de compression inconnu dans la frame " +
                              std::to_string(frameIdx) + ", cel " + std::to_string(cel) +
                              ": " + std::to_string(compType));
                    continue;
            }
        }

        if (pixelBuf.size() < pixel_count) {
            log_error(m_srcPath, "Données de pixels insuffisantes pour la frame " + std::to_string(frameIdx) +
                      ", cel " + std::to_string(cel) +
                      " (attendu " + std::to_string(pixel_count) +
                      ", obtenu " + std::to_string(pixelBuf.size()) + ")");
            continue;
        }

        auto scaledPixels = rescaleCel(pixelBuf, w, h, vScale, m_frameMetadata[frameIdx][cel].y, m_srcPath);
        int newH = (vScale == 100 || vScale == 0) ? h : h * vScale / 100;

        rgba_buffer.clear();
        static size_t lastCapacity = 0;
        
        try {
            rgba_buffer.resize(static_cast<size_t>(w) * newH * 4);
        } catch (const std::bad_alloc&) {
            log_error(m_srcPath, "Échec de l'allocation mémoire pour le buffer RGBA : " + std::to_string(w) + "x" + std::to_string(newH));
            continue;
        }

        if (rgba_buffer.capacity() > lastCapacity) {
            lastCapacity = rgba_buffer.capacity();
            rgba_buffer.reserve(lastCapacity);
        }

        for (size_t i = 0; i < static_cast<size_t>(w) * newH; ++i) {
            uint8_t idx = to_u8(scaledPixels[i]);
            if (idx >= 256) {
                rgba_buffer[i * 4 + 0] = 0;
                rgba_buffer[i * 4 + 1] = 0;
                rgba_buffer[i * 4 + 2] = 0;
                rgba_buffer[i * 4 + 3] = 255;
                continue;
            }
            size_t paletteIdx = idx * 3;
            if (m_hasPalette && paletteIdx + 2 < m_palette.size()) {
                rgba_buffer[i * 4 + 0] = to_u8(m_palette[paletteIdx + 0]);
                rgba_buffer[i * 4 + 1] = to_u8(m_palette[paletteIdx + 1]);
                rgba_buffer[i * 4 + 2] = to_u8(m_palette[paletteIdx + 2]);
            } else {
                rgba_buffer[i * 4 + 0] = idx;
                rgba_buffer[i * 4 + 1] = idx;
                rgba_buffer[i * 4 + 2] = idx;
            }
            rgba_buffer[i * 4 + 3] = 255;
        }
        std::ostringstream oss;
        oss << "frame_" << frameIdx << "_cel_" << cel << ".png";
        std::string filename = oss.str();
        fs::path outPath = dir / filename;

        if (!is_valid_filename(filename)) {
            oss.str("");
            oss << "frm" << frameIdx << "_c" << cel << ".png";
            filename = oss.str();
            outPath = dir / filename;
            if (!is_valid_filename(filename)) outPath = dir / ("cel_" + std::to_string(cel) + ".png");
        }

        constexpr size_t kMaxFileName = FILENAME_MAX - 10;
        if (outPath.string().size() > kMaxFileName) {
            oss.str("");
            oss << "frm" << frameIdx << "_c" << cel << ".png";
            filename = oss.str();
            outPath = dir / filename;
            if (outPath.string().size() > kMaxFileName) {
                outPath = dir / ("cel_" + std::to_string(cel) + ".png");
            }
        }
        fs::path longOutPath = make_long_path(outPath);
        if (!stbi_write_png(longOutPath.string().c_str(), w, newH, 4, rgba_buffer.data(), w * 4)) {
            log_error(m_srcPath, "Échec de l'écriture de la frame : " + outPath.string());
        } else {
            celCount++;
            log_info(m_srcPath, "Frame " + std::to_string(frameIdx) + 
                     ": cel " + std::to_string(cel) + " extraite (" + 
                     std::to_string(w) + "x" + std::to_string(newH) + ")");
        }
    }
    if (celCount > 0) {
        log_info(m_srcPath, "Extrait " + std::to_string(celCount) + " cels de la frame " + std::to_string(frameIdx));
    }
}

void RobotExtractor::processAudioBlock(std::span<const uint8_t> block, int16_t& predictorEven, int16_t& predictorOdd) {
    if (block.size() < 8) {
        log_error(m_srcPath, "Taille de bloc audio invalide : " + std::to_string(block.size()) + " octets");
        return;
    }
    uint32_t position = read_scalar<uint32_t>(block, false, 0);
    uint32_t size = read_scalar<uint32_t>(block, false, 4);

    if (static_cast<size_t>(8 + size) > block.size()) {
        log_error(m_srcPath, "Incohérence de taille de bloc audio : attendu " + std::to_string(8 + size) +
                  ", obtenu " + std::to_string(block.size()));
        return;
    }

    uint8_t parity = position % 2;
    if (parity > 1) {
        log_error(m_srcPath, "Parité audio invalide : " + std::to_string(parity) + ", retour à pair");
        parity = 0;
    }

    auto audioData = block.subspan(8, size);
    auto pcm = dpcm16_decompress(audioData, parity == 0 ? predictorEven : predictorOdd);
    if (pcm.empty()) {
        log_error(m_srcPath, "Données PCM vides pour le bloc audio à la position " + std::to_string(position));
        return;
    }

    m_audioBlocks.push_back({position, pcm, parity == 0});
    if (parity == 0) {
        predictorEven = pcm.back();
    } else {
        predictorOdd = pcm.back();
    }
}

bool RobotExtractor::validate() {
    m_fp.open(m_srcPath, std::ios::binary);
    if (!m_fp) {
        log_error(m_srcPath, "Impossible d'ouvrir le fichier pour validation");
        return false;
    }
    if (!readHeader()) {
        log_error(m_srcPath, "Échec de la validation du fichier : en-tête invalide");
        return false;
    }

    for (uint16_t fIdx = 0; fIdx < m_numFrames; ++fIdx) {
        auto currentPos = m_fp.tellg();
        m_fp.seekg(0, std::ios::end);
        auto fileSize = m_fp.tellg();
        m_fp.seekg(currentPos);

        if (currentPos == -1 || fileSize == -1) {
            log_error(m_srcPath, "Erreur de position de fichier à la frame " + std::to_string(fIdx));
            return false;
        }

        uint32_t vidSz = m_videoSizes[fIdx];
        uint32_t pktSz = m_packetSizes[fIdx];
        uint32_t audioSz = (pktSz > vidSz) ? (pktSz - vidSz) : 0;

        if (static_cast<std::streamoff>(fileSize - currentPos) < static_cast<std::streamoff>(vidSz + audioSz)) {
            log_error(m_srcPath, "Fichier tronqué à la frame " + std::to_string(fIdx));
            return false;
        }

        m_fp.seekg(vidSz + audioSz, std::ios::cur);
        if (m_fp.fail()) {
            log_error(m_srcPath, "Échec du positionnement après la frame " + std::to_string(fIdx));
            return false;
        }
    }

    log_info(m_srcPath, "Validation du fichier réussie : " + std::to_string(m_numFrames) + " frames, " +
             (m_hasPalette ? "avec palette, " : "sans palette, ") +
             (m_hasAudio ? "avec audio" : "sans audio"));
    return true;
}

bool RobotExtractor::extract() {
    m_fp.open(m_srcPath, std::ios::binary);
    if (!m_fp) {
        log_error(m_srcPath, "Impossible d'ouvrir le fichier");
        return false;
    }
    if (!readHeader()) return false;

    fs::path outDir = g_outputDir.empty() ? m_srcPath.stem().string() + "_rbt" : g_outputDir;
    if (outDir.string().size() > kMaxPathLength) {
        log_error(m_srcPath, "Chemin du répertoire de sortie trop long : " + outDir.string());
        return false;
    }
    try {
        fs::create_directories(make_long_path(outDir / "frames"));
    } catch (const std::exception& e) {
        log_error(m_srcPath, "Échec de la création du répertoire de sortie : " + std::string(e.what()));
        return false;
    }

    exportPalette(outDir / "palette.png");

    size_t totalCelCount = 0;
    auto startTime = std::chrono::steady_clock::now();
    for (uint16_t fIdx = 0; fIdx < m_numFrames; ++fIdx) {
        auto currentPos = m_fp.tellg();
        m_fp.seekg(0, std::ios::end);
        auto fileSize = m_fp.tellg();
        m_fp.seekg(currentPos);

        if (currentPos == -1 || fileSize == -1) {
            log_error(m_srcPath, "Erreur de position de fichier à la frame " + std::to_string(fIdx));
            break;
        }

        uint32_t vidSz = m_videoSizes[fIdx];
        uint32_t pktSz = m_packetSizes[fIdx];
        uint32_t audioSz = (pktSz > vidSz) ? (pktSz - vidSz) : 0;

        if (static_cast<std::streamoff>(fileSize - currentPos) < static_cast<std::streamoff>(vidSz + audioSz)) {
            log_error(m_srcPath, "Fichier tronqué à la frame " + std::to_string(fIdx));
            break;
        }

        std::vector<uint8_t> video;
        try {
            video.resize(vidSz);
        } catch (const std::bad_alloc&) {
            log_error(m_srcPath, "Échec de l'allocation mémoire pour la frame vidéo " + std::to_string(fIdx));
            continue;
        }
        m_fp.read(reinterpret_cast<char*>(video.data()), vidSz);
        if (static_cast<std::streamsize>(m_fp.gcount()) != static_cast<std::streamsize>(vidSz)) {
            log_error(m_srcPath, "Échec de la lecture de la frame vidéo " + std::to_string(fIdx));
            continue;
        }

        std::vector<uint8_t> audio;
        if (audioSz > 0) {
            try {
                audio.resize(audioSz);
            } catch (const std::bad_alloc&) {
                log_error(m_srcPath, "Échec de l'allocation mémoire pour la frame audio " + std::to_string(fIdx));
                continue;
            }
            m_fp.read(reinterpret_cast<char*>(audio.data()), audioSz);
            if (static_cast<std::streamsize>(m_fp.gcount()) != static_cast<std::streamsize>(audioSz)) {
                log_error(m_srcPath, "Échec de la lecture de la frame audio " + std::to_string(fIdx));
            }
        }

        if (!video.empty()) {
            size_t frameCelCount = 0;
            exportFrame(fIdx, video, outDir / "frames", frameCelCount);
            totalCelCount += frameCelCount;
            show_progress(fIdx + 1, m_numFrames, startTime, m_srcPath);
        }
        if (!audio.empty()) {
            processAudioBlock(audio, m_predictorEven, m_predictorOdd);
        }
    }
    if (!g_quiet) std::cout << "\n";

    if (m_hasAudio && !m_audioBlocks.empty()) {
        std::sort(m_audioBlocks.begin(), m_audioBlocks.end(),
                  [](const AudioBlock& a, const AudioBlock& b) { return a.position < b.position; });

        size_t totalSamplesEven = 0, totalSamplesOdd = 0;
        for (const auto& block : m_audioBlocks) {
            if (block.isEven) totalSamplesEven += block.samples.size();
            else totalSamplesOdd += block.samples.size();
        }

        std::vector<int16_t> audioEven, audioOdd;
        try {
            audioEven.reserve(totalSamplesEven);
            audioOdd.reserve(totalSamplesOdd);
        } catch (const std::bad_alloc&) {
            log_error(m_srcPath, "Échec de l'allocation mémoire pour les buffers audio");
            return false;
        }
        for (const auto& block : m_audioBlocks) {
            if (block.isEven) {
                audioEven.insert(audioEven.end(), block.samples.begin(), block.samples.end());
            } else {
                audioOdd.insert(audioOdd.end(), block.samples.begin(), block.samples.end());
            }
        }
        uint32_t sampleRate = 22050;
        if (m_version >= 5) {
            if (m_audioBlkSize == 11025 || m_audioBlkSize == 22050 ||
                m_audioBlkSize == 44100 || m_audioBlkSize == 48000) {
                sampleRate = m_audioBlkSize;
            } else if (m_audioBlkSize > 1000 && m_audioBlkSize <= 65535) {
                log_error(m_srcPath, "Taille de bloc audio inhabituelle " + std::to_string(m_audioBlkSize) + ", retour à 22050 Hz");
            }
        }
        write_wav(outDir / "audio.wav", audioEven, audioOdd, sampleRate);
    }

    fs::path jsonPath = make_long_path(outDir / "metadata.json");
    std::ofstream jsonFile(jsonPath);
    if (jsonFile) {
        nlohmann::json j;
        j["version"] = m_version;
        j["frame_rate"] = m_frameRate;
        j["xRes"] = m_xRes;
        j["yRes"] = m_yRes;
        j["video_sizes"] = m_videoSizes;
        j["packet_sizes"] = m_packetSizes;
        j["cue_times"] = m_cueTimes;
        j["cue_values"] = m_cueValues;
        j["frame_metadata"] = nlohmann::json::array();
        for (size_t frameIdx = 0; frameIdx < m_frameMetadata.size(); ++frameIdx) {
            nlohmann::json frameJson = nlohmann::json::array();
            for (size_t celIdx = 0; celIdx < m_frameMetadata[frameIdx].size(); ++celIdx) {
                const auto& cel = m_frameMetadata[frameIdx][celIdx];
                frameJson.push_back({
                    {"x", cel.x},
                    {"y", cel.y},
                    {"w", cel.w},
                    {"h", cel.h},
                    {"vScale", cel.vScale},
                    {"unk0", cel.unk0},
                    {"idx", celIdx}
                });
            }
            j["frame_metadata"].push_back(frameJson);
        }
        jsonFile << std::setw(2) << j;
        log_info(m_srcPath, "Métadonnées exportées vers " + jsonPath.string());
    } else {
        log_error(m_srcPath, "Échec de l'écriture des métadonnées : " + jsonPath.string());
    }

    if (!g_quiet) {
        log_info(m_srcPath, "[✔] Extrait " + std::to_string(totalCelCount) + " cels vers " + outDir.string());
    }
    return true;
}

// ─────────────────────────────────────────────────────────────────────────────
//  main
// ─────────────────────────────────────────────────────────────────────────────
int main(int argc, char** argv) {
#if defined(_WIN32)
    if (!SetConsoleOutputCP(CP_UTF8) || !SetConsoleCP(CP_UTF8)) {
        std::cerr << "[!] Avertissement : Échec du réglage de l'encodage de la console en UTF-8\n";
    }
    if (_setmode(_fileno(stdout), _O_TEXT) == -1 || _setmode(_fileno(stderr), _O_TEXT) == -1) {
        log_error(fs::path(), "Échec du réglage du mode texte pour la sortie console");
    }
#endif
    std::vector<std::string> files;
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg.starts_with("--")) {
            bool known = false;
            if (arg == "--quiet") {
                g_quiet = true;
                known = true;
            } else if (arg == "--validate") {
                g_validateOnly = true;
                known = true;
            } else if (arg.find("--gamma=") == 0) {
                g_gammaMode = arg.substr(8);
                if (g_gammaMode != "legacy" && g_gammaMode != "precise" && g_gammaMode != "off") {
                    log_error(fs::path(), "Mode gamma invalide : " + g_gammaMode + ", utilisation de precise");
                    g_gammaMode = "precise";
                }
                known = true;
            } else if (arg.find("--output-dir=") == 0) {
                g_outputDir = arg.substr(13);
                if (g_outputDir.string().size() > kMaxPathLength) {
                    log_error(fs::path(), "Répertoire de sortie invalide : " + g_outputDir.string());
                    return 1;
                }
                known = true;
            } else if (arg == "--version") {
                std::cout << "robot_extractor " << RobotExtractor::EXTRACTOR_VERSION << '\n';
                return 0;
            }
            
            if (!known) {
                std::cerr << "[!] Erreur : Option inconnue '" << arg << "'\n";
                std::cout << "Usage : " << argv[0] << " [--quiet] [--validate] [--gamma={legacy,precise,off}] [--output-dir=dir] [--version] file.rbt [...]\n";
                return 1;
            }
        } else {
            files.emplace_back(arg);
        }
    }
    if (files.empty()) {
        std::cout << "Usage : " << argv[0] << " [--quiet] [--validate] [--gamma={legacy,precise,off}] [--output-dir=dir] [--version] file.rbt [...]\n";
        return 1;
    }
    int success = 0;
    for (const auto& file : files) {
        try {
            if (!g_quiet) log_info(fs::path(file), "Traitement de " + file);
            fs::path src = make_long_path(fs::path(file));
            RobotExtractor rex(src);
            if (g_validateOnly) {
                if (rex.validate()) success++;
            } else {
                if (rex.extract()) success++;
            }
        } catch (const std::exception& e) {
            log_error(fs::path(file), "Erreur lors du traitement du fichier : " + std::string(e.what()));
        }
    }
    return (success == files.size()) ? 0 : 1;
}